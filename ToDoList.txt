NON RICORDO SE AVEVO AGGIUSTATO semaphore.c - sem_getval: Failed to get semaphore value
gestire l'uscita dal processo nel caso non si trova la mem condivisa/ semaforo

magari aggiungere anche dei limiti sulla quantità di atomi creabili come atomi iniziali  perche se 
inizializzo l'esecuzione con un numero troppo alto di atomi , che supera gia i limiti di sistema, es quelli
di cgroup o di user_limit, allora le fork potrebbero fallire prima dell'inizio dell'esecuzione.
vedere come gestire


aggiungere un semaforo che avvisa che ci sono delle fork in corso cosi che master deve aspettare che tutte le 
fork teminino poi puo chiudersi e nel frattempo pero non possono essere vviate nuove fork
quindi di sicuro master o chi di sovere setta il valore di semaforo di esecuzione a 0 e poi si aspettano le foork

errore del makefile quando uso make killall kill  (non è proprio un errore ma meglio aggiustare macari)


processo inibitore 

DA FARE ME SA assorbe parte della quantit`a di energia prodotta dalla scissione dell’atomo diminuendo la quantit`a di energia
che viene liberata (QUESTO AGISCE DIRETTAMENTE NELL'ATOMO, ATOMO CONTROLLA MEM CONDIVIDSA CHE L'INIBITOE SIA ATTIVATO E MODIFICA LA FUNZIONE DI ENERGIA LIBERATA
IMPLICA UN SEMAFORO O UNA VARIABILE IN MEMORIA CONDIVISA)


FATTO limita il numero di scissioni agendo sull’operazione di scissione rendendola probabilistica (ad esempio decidendo
se la scissione debba avvenire o meno oppure trasformando in scoria uno degli atomi prodotti dopo la scissione)(STESSA COSA, L'ATOMO CONTROLLA CHE L'INIBITORE SIA ATTIVO CON UN SEMAFORO E 
USA UNA FUNZIONE RANDOMICA DI 3 NUMERI PER SCISSIONE, NON SCISSIONE O SCISSIONE E UNO DEI DUE ATOMI PRODOTTI DIVENTA SCORIA)
4
Il meccanismo di assorbimento e quello di limitazione delle scissioni sono scelti dal programmatore e devono
essere basati su qualche criterio adattivo.


FATTO La presenza o meno del processo inibitore deve poter essere scelta a run-time, all’inizio della simulazione.

 Nel caso in cui il processo inibitore sia attivo, ci si aspetta che la terminazione per “explode” e “meltdown” non avvenga.
Inoltre, l’utente deve poter fermare (e far ripartire) il processo inibitore pi`u volte da terminale attraverso un
meccanismo a scelta del programmatore



    PER FARLO BLOCCARE O RIPARTIRE SI USANO SEGNALI DA LINE ADI COMANDO

    #include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <signal.h>
#include <string.h>

volatile sig_atomic_t running = 1;

void signal_handler(int sig) {
    if (sig == SIGUSR1) {
        running = 0; // Stop the inhibitor
    } else if (sig == SIGUSR2) {
        running = 1; // Start the inhibitor
    }
}

int main() {
    // Set up signal handlers
    signal(SIGUSR1, signal_handler);
    signal(SIGUSR2, signal_handler);

    printf("Inhibitor process started with PID: %d\n", getpid());

    while (1) {
        if (running) {
            printf("Inhibitor running...\n");
        } else {
            printf("Inhibitor stopped...\n");
        }
        sleep(1); // Simulate work
    }

    return 0;
}


2. Gestire i Segnali da Terminale

Puoi inviare segnali a un processo specifico utilizzando il comando kill da terminale. Ad esempio:

    Per fermare il processo inibitore:

    sh

kill -SIGUSR1 <PID>

Per far ripartire il processo inibitore:

sh

    kill -SIGUSR2 <PID>

3. Avviare il Processo Inibitore

Compila e avvia il processo inibitore:

sh

gcc -o inhibitor inhibitor.c
./inhibitor

4. Inviare i Segnali dal Terminale

Trova il PID del processo inibitore (verrà stampato dal processo stesso quando viene avviato). Quindi, utilizza kill per inviare i segnali appropriati:

sh

# Fermare il processo inibitore
kill -SIGUSR1 <PID>

# Far ripartire il processo inibitore
kill -SIGUSR2 <PID>

Vantaggi dei Segnali

    Semplicità: I segnali sono facili da utilizzare e non richiedono la configurazione di risorse aggiuntive come file o socket.
    Efficienza: L'uso dei segnali è molto efficiente e non introduce ritardi significativi nella comunicazione.
    Portabilità: I segnali sono una funzionalità standard di Unix/Linux e funzionano su tutte le distribuzioni.

Conclusione

L'uso dei segnali è una soluzione standard e efficace per controllare il comportamento di un processo da terminale. È particolarmente utile per azioni di controllo come fermare o far ripartire un processo senza modificare il codice sorgente principale o utilizzare meccanismi di comunicazione più complessi.






