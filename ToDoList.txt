semaphore.c - sem_getval: Failed to get semaphore value
gestire l'uscita dal processo nel caso non si trova la mem condivisa/ semaforo


aggiungere un semaforo che avvisa che ci sono delle fork in corso cosi che master deve aspettare che tutte le 
fork teminino poi puo chiudersi e nel frattempo pero non possono essere vviate nuove fork
quindi di sicuro master o chi di sovere setta il valore di semaforo di esecuzione a 0 e poi si aspettano le foork

errore del makefile quando uso make killall kill


processo inibitore 


    PER FARLO BLOCCARE O RIPARTIRE SI USANO SEGNALI DA LINE ADI COMANDO

    #include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <signal.h>
#include <string.h>

volatile sig_atomic_t running = 1;

void signal_handler(int sig) {
    if (sig == SIGUSR1) {
        running = 0; // Stop the inhibitor
    } else if (sig == SIGUSR2) {
        running = 1; // Start the inhibitor
    }
}

int main() {
    // Set up signal handlers
    signal(SIGUSR1, signal_handler);
    signal(SIGUSR2, signal_handler);

    printf("Inhibitor process started with PID: %d\n", getpid());

    while (1) {
        if (running) {
            printf("Inhibitor running...\n");
        } else {
            printf("Inhibitor stopped...\n");
        }
        sleep(1); // Simulate work
    }

    return 0;
}


2. Gestire i Segnali da Terminale

Puoi inviare segnali a un processo specifico utilizzando il comando kill da terminale. Ad esempio:

    Per fermare il processo inibitore:

    sh

kill -SIGUSR1 <PID>

Per far ripartire il processo inibitore:

sh

    kill -SIGUSR2 <PID>

3. Avviare il Processo Inibitore

Compila e avvia il processo inibitore:

sh

gcc -o inhibitor inhibitor.c
./inhibitor

4. Inviare i Segnali dal Terminale

Trova il PID del processo inibitore (verrà stampato dal processo stesso quando viene avviato). Quindi, utilizza kill per inviare i segnali appropriati:

sh

# Fermare il processo inibitore
kill -SIGUSR1 <PID>

# Far ripartire il processo inibitore
kill -SIGUSR2 <PID>

Vantaggi dei Segnali

    Semplicità: I segnali sono facili da utilizzare e non richiedono la configurazione di risorse aggiuntive come file o socket.
    Efficienza: L'uso dei segnali è molto efficiente e non introduce ritardi significativi nella comunicazione.
    Portabilità: I segnali sono una funzionalità standard di Unix/Linux e funzionano su tutte le distribuzioni.

Conclusione

L'uso dei segnali è una soluzione standard e efficace per controllare il comportamento di un processo da terminale. È particolarmente utile per azioni di controllo come fermare o far ripartire un processo senza modificare il codice sorgente principale o utilizzare meccanismi di comunicazione più complessi.






assorbe parte della quantit`a di energia prodotta dalla scissione dell’atomo diminuendo la quantit`a di energia
che viene liberata (QUESTO AGISCE DIRETTAMENTE NELL'ATOMO, QUESTO CONTROLLA MEM CONDIVIDSA CHE L'INIBITOE SIA ATTIVATO E MODIFICA LA FUNZIONE DI ENERGIA LIBERATA
IMPLICA UN SEMAFORO O UNA VARIABILE IN MEMORIA CONDIVISA)


• limita il numero di scissioni agendo sull’operazione di scissione rendendola probabilistica (ad esempio decidendo
se la scissione debba avvenire o meno oppure trasformando in scoria uno degli atomi prodotti dopo la scissione)(STESSA COSA, L'ATOMO CONTROLLA CHE L'INIBITORE SIA ATTIVO CON UN SEMAFORO E 
USA UNA FUNZIONE RANDOMICA DI 3 NUMERI PER SCISSIONE, NON SCISSIONE O SCISSIONE E UNO DEI DUE ATOMI PRODOTTI DIVENTA SCORIA)
4
Il meccanismo di assorbimento e quello di limitazione delle scissioni sono scelti dal programmatore e devono
essere basati su qualche criterio adattivo.


FATTO La presenza o meno del processo inibitore deve poter essere scelta a run-time, all’inizio della simulazione.

 Nel caso in cui il processo inibitore sia attivo, ci si aspetta che la terminazione per “explode” e “meltdown” non avvenga.
Inoltre, l’utente deve poter fermare (e far ripartire) il processo inibitore pi`u volte da terminale attraverso un
meccanismo a scelta del programmatore

Codice Aggiornato

c

#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define MAX_ATOMS 5000

// Funzione per calcolare la probabilità adattiva
double adaptive_probability(int active_atoms) {
    if (active_atoms >= MAX_ATOMS) {
        return 1.0; // Blocco totale se abbiamo raggiunto il limite
    }
    return (double)active_atoms / MAX_ATOMS; // Probabilità adattiva
}

// Funzione per decidere se bloccare la scissione o trasformare in scoria
int should_block_or_waste_fission(int active_atoms) {
    double probability = adaptive_probability(active_atoms);
    double random_value = (double)rand() / RAND_MAX; // Numero casuale tra 0 e 1
    if (random_value < probability) {
        return rand() % 2; // Restituisce 0 o 1 casualmente per blocco o scoria
    }
    return -1; // Indica che la scissione può avvenire
}

// Simula la scissione di un atomo
void fission(int *active_atoms) {
    int decision = should_block_or_waste_fission(*active_atoms);
    if (decision == 0) {
        printf("Fission converted to waste.\n");
        return;
    } else if (decision == 1) {
        printf("Fission blocked.\n");
        return;
    }

    // Altrimenti, la scissione avviene normalmente
    printf("Fission occurs. Active atoms increased.\n");
    *active_atoms += 1; // Aumentiamo il conteggio degli atomi attivi
}

int main() {
    srand(time(NULL)); // Inizializza il generatore di numeri casuali

    int active_atoms = 0;
    
    // Simuliamo una serie di scissioni
    for (int i = 0; i < 100; i++) {
        fission(&active_atoms);
        printf("Active atoms: %d\n", active_atoms);
        if (active_atoms >= MAX_ATOMS) {
            printf("Reached maximum number of active atoms.\n");
            break;
        }
    }

    return 0;
}

Spiegazione del Codice

    adaptive_probability: Questa funzione calcola la probabilità di bloccare la scissione in base al numero di atomi attivi. La probabilità aumenta linearmente man mano che il numero di atomi attivi si avvicina al massimo consentito.

    should_block_or_waste_fission: Questa funzione utilizza la probabilità adattiva per decidere se bloccare la scissione o trasformarla in scoria. Se il valore casuale è inferiore alla probabilità adattiva, la funzione restituisce casualmente 0 o 1 (blocco o scoria). Altrimenti, restituisce -1 per indicare che la scissione può avvenire.

    fission: Questa funzione verifica la decisione restituita da should_block_or_waste_fission. Se la decisione è 0, la scissione viene trasformata in scoria. Se la decisione è 1, la scissione viene bloccata. Se la decisione è -1, la scissione avviene normalmente e il numero di atomi attivi aumenta.

    main: Questa funzione simula una serie di scissioni per dimostrare il funzionamento della logica di blocco adattiva e della trasformazione in scoria. Si interrompe quando il numero massimo di atomi attivi è raggiunto.

Considerazioni Finali

Con questo approccio, la probabilità di bloccare la scissione o trasformarla in scoria aumenta gradualmente man mano che ci avviciniamo al limite massimo di atomi attivi, rendendo il sistema sempre più restrittivo. Questo garantisce che il numero di atomi attivi rimanga sotto controllo e non superi il limite massimo.
c'è un comando per vedere qual'è il limite di processi creabili dal utente su linux? in modo tale che il numero massimo di atomi creabili combaci col num max di processi creabili?
ChatGPT

Sì, puoi utilizzare il comando ulimit su Linux per vedere il limite massimo di processi che un utente può creare. Specificamente, il comando ulimit -u ti mostrerà il numero massimo di processi che l'utente corrente può avere contemporaneamente.

Ecco come puoi fare:

sh

ulimit -u

Questo comando restituirà un numero che rappresenta il massimo numero di processi che l'utente corrente può creare.

Se vuoi vedere o impostare i limiti per tutti gli utenti, puoi controllare il file /etc/security/limits.conf. Ecco come puoi vedere il contenuto del file:

sh

cat /etc/security/limits.conf

Modifica del limite di processi

Se hai bisogno di aumentare il limite massimo di processi, puoi farlo aggiungendo o modificando le linee in /etc/security/limits.conf:

plaintext

# Example entry to set a limit for a specific user
username     hard    nproc       10000

# Example entry to set a limit for all users
*            hard    nproc       10000

Dopo aver apportato modifiche a questo file, potrebbe essere necessario riavviare il sistema o almeno la sessione dell'utente per applicare le nuove impostazioni.
Uso nel Programma

Puoi ottenere questo valore nel tuo programma in C e utilizzarlo per impostare il numero massimo di atomi attivi. Ecco un esempio di come puoi fare questo:

c

#include <stdio.h>
#include <sys/resource.h>
#include <unistd.h>

int get_max_processes() {
    struct rlimit limit;
    if (getrlimit(RLIMIT_NPROC, &limit) == 0) {
        return (int)limit.rlim_cur;
    } else {
        perror("getrlimit");
        return -1;
    }
}

int main() {
    int max_processes = get_max_processes();
    if (max_processes != -1) {
        printf("Maximum number of processes: %d\n", max_processes);
    }
    return 0;
}

Questo programma recupera il limite massimo di processi per l'utente corrente e lo stampa. Puoi utilizzare questo valore per impostare il numero massimo di atomi attivi nel tuo programma.








#include <stdio.h>
#include <stdlib.h>
#include <limits.h>  // Include PATH_MAX
#include <string.h>  // Include memset

void get_process_limit_path(char *path_buffer, size_t buffer_size, pid_t pid) {
    snprintf(path_buffer, buffer_size, "/sys/fs/cgroup/user.slice/user-1000.slice/user@1000.service/app.slice/snap.code.code-d6670ae6-8f30-47c3-bc0b-544b579abf07.scope/pids.peak", pid);
}

int main() {
    char path[PATH_MAX];
    pid_t pid = getpid();  // Use the current process ID, change this as needed

    get_process_limit_path(path, sizeof(path), pid);
    
    FILE *file = fopen(path, "r");

    if (file == NULL) {
        perror("Failed to open file");
        return EXIT_FAILURE;
    }

    char buffer[128];
    if (fgets(buffer, sizeof(buffer), file) == NULL) {
        perror("Failed to read file");
        fclose(file);
        return EXIT_FAILURE;
    }

    fclose(file);

    if (buffer[0] == 'm') {
        printf("No limit on the number of processes\n");
    } else {
        int max_processes = atoi(buffer);
        printf("Maximum number of processes: %d\n", max_processes);
    }

    return EXIT_SUCCESS;
}



Sì, puoi ottenere il valore della memoria libera e salvarlo in una variabile in un programma C. Su Linux, uno dei modi per farlo è leggere il file /proc/meminfo, che contiene informazioni sulla memoria del sistema. Ecco un esempio di come puoi fare questo:

c

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

long get_free_memory() {
    FILE *file = fopen("/proc/meminfo", "r");
    if (file == NULL) {
        perror("fopen");
        return -1;
    }

    char line[256];
    long free_memory = -1;

    while (fgets(line, sizeof(line), file)) {
        if (strncmp(line, "MemFree:", 8) == 0) {
            sscanf(line + 8, "%ld", &free_memory);
            free_memory *= 1024; // Convert kB to bytes
            break;
        }
    }

    fclose(file);
    return free_memory;
}

int main() {
    long free_memory = get_free_memory();
    if (free_memory != -1) {
        printf("Free memory: %ld bytes\n", free_memory);
    } else {
        printf("Failed to get free memory.\n");
    }
    return 0;
}

Spiegazione del codice

    Apertura del file /proc/meminfo:

    c

FILE *file = fopen("/proc/meminfo", "r");
if (file == NULL) {
    perror("fopen");
    return -1;
}

Questo apre il file /proc/meminfo in modalità di lettura. Se l'apertura del file fallisce, stampa un messaggio di errore e ritorna -1.

Lettura del file riga per riga:

c

char line[256];
long free_memory = -1;

while (fgets(line, sizeof(line), file)) {
    if (strncmp(line, "MemFree:", 8) == 0) {
        sscanf(line + 8, "%ld", &free_memory);
        free_memory *= 1024; // Convert kB to bytes
        break;
    }
}

Questo legge il file riga per riga finché non trova la linea che inizia con "MemFree:". Quando trova questa linea, usa sscanf per estrarre il valore della memoria libera e lo converte da kilobytes a bytes.

Chiusura del file:

c

fclose(file);

Questo chiude il file dopo aver finito di leggerlo.

Uso del valore della memoria libera:

c

    int main() {
        long free_memory = get_free_memory();
        if (free_memory != -1) {
            printf("Free memory: %ld bytes\n", free_memory);
        } else {
            printf("Failed to get free memory.\n");
        }
        return 0;
    }

    Questo chiama la funzione get_free_memory e stampa il valore della memoria libera se l'operazione ha avuto successo.

Questo programma ti permette di ottenere il valore della memoria libera e di salvarlo in una variabile in C.