FATTO aggiungere stampe di qunta energia assorbe inibitore e quante scissioni/operazioni fa

sembra che gli accessi alla mem condivisa da parte degli atomi non avvengano in modo cronologico 
facendo si che quantità alte di energia liberate quando si era lontani da explode vengano scritte in memoria
quando si è piu vicini a explode 

EXPLODE da atom non fa terminare l'esecuzione correttamante, gli atomi rimangono in vita
+ master non si chiude quindi si è costretti a fare makekillall-kill per uccidere tutti i processi
dell esecuzione ma rimangono ettive le risorse ipc che devono essere rimosse con make clean se no alla prossima
esecuzione darà errore del semaforo 
Risolto: praticamente explode avviene dentro una sezione ad esecuzione atomica di atom e non rimettevo i semafori
a valori di semaforo libero cosi che tutti gli atomi che aspettavano su quel semaforo rimanevano sempre li ad aspettare

aggiungere le stampe delle operazioni del'inibiotre e 

"AGGIUSTATO" semaphore.c - sem_getval: Failed to get semaphore value
gestire l'uscita dal processo nel caso non si trova la mem condivisa/ semaforo
Grazie all'errore in explode ho capito n po... adesso nel migliore dei casi master e gli atomi terminano correttamente
Nel peggiore dei casi rimangono comunque dei processi attivi ma senza errori, rimangono stranamente in Sleep, notabile
scrivendo ps aux nel terminale e i processi ./atom sono in stato S+ (che sarebbe sleep)
- scavando nei meandri ho capito che praticamente finiscono le risore per fare fork, allora i processi gia creati terminano
correttamente diventando zombie. gli zombie occupano comunque spazio nella tabella dei processi facendo si che gli altri processi che si devono creare
con fork non possono. l'unico modo per liberare gli zombie è di fare una wait() o waitpid() che aspettano la terminazione
dei figli conoscendo il loro pid e quindi puliscono gli zombie, oppure terminiamo il padre, cosi gli zombie vengono adottati
da init che li gestirà al meglio(li toglie di mezzo)
-noi non ci salviamo i pid dei figli quindi mi sembra piu logico terminare il padre quando i figli smettono di terminare da soli
cosi gli zombie se ne vanno e gli altri procesi in sleep perche non possono crearsi, finalmente si tolgono di mezzo da soli nel modo giusto
-penso che sia la sola soluzione perche ho anche provato a inviare segnali ai processi in sleep ma non li ricevono quindi ho 
pensato che non sono nemmeno stati inizializzati anche perche poi nelle stampe del terminale mi usciva scritto un errore sh: 1: Cannot fork
quindi sembra che i processi volevano an cora forkarsi? ma io che ne so. poi bho è solo un mio pensiero.

magari aggiungere anche dei limiti sulla quantità di atomi creabili come atomi iniziali  perche se 
inizializzo l'esecuzione con un numero troppo alto di atomi , che supera gia i limiti di sistema, es quelli
di cgroup o di user_limit, allora le fork potrebbero fallire prima dell'inizio dell'esecuzione.
vedere come gestire


aggiungere un semaforo che avvisa che ci sono delle fork in corso cosi che master deve aspettare che tutte le 
fork teminino poi puo chiudersi e nel frattempo pero non possono essere vviate nuove fork
quindi di sicuro master o chi di sovere setta il valore di semaforo di esecuzione a 0 e poi si aspettano le foork

errore del makefile quando uso make killall kill  (non è proprio un errore ma meglio aggiustare macari)


processo inibitore 

DA FARE ME SA assorbe parte della quantit`a di energia prodotta dalla scissione dell’atomo diminuendo la quantit`a di energia
che viene liberata (QUESTO AGISCE DIRETTAMENTE NELL'ATOMO, ATOMO CONTROLLA MEM CONDIVIDSA CHE L'INIBITOE SIA ATTIVATO E MODIFICA LA FUNZIONE DI ENERGIA LIBERATA
IMPLICA UN SEMAFORO O UNA VARIABILE IN MEMORIA CONDIVISA)


FATTO limita il numero di scissioni agendo sull’operazione di scissione rendendola probabilistica (ad esempio decidendo
se la scissione debba avvenire o meno oppure trasformando in scoria uno degli atomi prodotti dopo la scissione)(STESSA COSA, L'ATOMO CONTROLLA CHE L'INIBITORE SIA ATTIVO CON UN SEMAFORO E 
USA UNA FUNZIONE RANDOMICA DI 3 NUMERI PER SCISSIONE, NON SCISSIONE O SCISSIONE E UNO DEI DUE ATOMI PRODOTTI DIVENTA SCORIA)
4
Il meccanismo di assorbimento e quello di limitazione delle scissioni sono scelti dal programmatore e devono
essere basati su qualche criterio adattivo.


FATTO La presenza o meno del processo inibitore deve poter essere scelta a run-time, all’inizio della simulazione.

 Nel caso in cui il processo inibitore sia attivo, ci si aspetta che la terminazione per “explode” e “meltdown” non avvenga.
Inoltre, l’utente deve poter fermare (e far ripartire) il processo inibitore pi`u volte da terminale attraverso un
meccanismo a scelta del programmatore



    PER FARLO BLOCCARE O RIPARTIRE SI USANO SEGNALI DA LINE ADI COMANDO

    #include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <signal.h>
#include <string.h>

volatile sig_atomic_t running = 1;

void signal_handler(int sig) {
    if (sig == SIGUSR1) {
        running = 0; // Stop the inhibitor
    } else if (sig == SIGUSR2) {
        running = 1; // Start the inhibitor
    }
}

int main() {
    // Set up signal handlers
    signal(SIGUSR1, signal_handler);
    signal(SIGUSR2, signal_handler);

    printf("Inhibitor process started with PID: %d\n", getpid());

    while (1) {
        if (running) {
            printf("Inhibitor running...\n");
        } else {
            printf("Inhibitor stopped...\n");
        }
        sleep(1); // Simulate work
    }

    return 0;
}


2. Gestire i Segnali da Terminale

Puoi inviare segnali a un processo specifico utilizzando il comando kill da terminale. Ad esempio:

    Per fermare il processo inibitore:

    sh

kill -SIGUSR1 <PID>

Per far ripartire il processo inibitore:

sh

    kill -SIGUSR2 <PID>

3. Avviare il Processo Inibitore

Compila e avvia il processo inibitore:

sh

gcc -o inhibitor inhibitor.c
./inhibitor

4. Inviare i Segnali dal Terminale

Trova il PID del processo inibitore (verrà stampato dal processo stesso quando viene avviato). Quindi, utilizza kill per inviare i segnali appropriati:

sh

# Fermare il processo inibitore
kill -SIGUSR1 <PID>

# Far ripartire il processo inibitore
kill -SIGUSR2 <PID>

Vantaggi dei Segnali

    Semplicità: I segnali sono facili da utilizzare e non richiedono la configurazione di risorse aggiuntive come file o socket.
    Efficienza: L'uso dei segnali è molto efficiente e non introduce ritardi significativi nella comunicazione.
    Portabilità: I segnali sono una funzionalità standard di Unix/Linux e funzionano su tutte le distribuzioni.

Conclusione

L'uso dei segnali è una soluzione standard e efficace per controllare il comportamento di un processo da terminale. È particolarmente utile per azioni di controllo come fermare o far ripartire un processo senza modificare il codice sorgente principale o utilizzare meccanismi di comunicazione più complessi.








robe da rimettere:
inibitore

#define _GNU_SOURCE

#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>
#include <signal.h>
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/sem.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <time.h>
#include <errno.h>
#include <string.h>

#include "../lib/semaphore.h"
#include "include/msg_comunication.h"
#include "include/shm_info.h"

struct stats { //struct stats è formata da puntatori a memoria condivisa
	//shm_n_atoms *atoms;
	//shm_energy *energy; //e  molte altre da implementare
	shm_info_t *info; //*inf = (shm_info_t *)shm_attach(shm_id); questo si trova nella funzione shm_info_attach, grazie a questo
	                  // adesso il puntatore di tipo shm_info_t punta ad un area di memoria condivisa allocata e vuota di granezza
					  //shm_info_t 
};

struct stats stats;
void close_and_exit();

int main(int argc, char *argv[]){
    printf("CIAO SONO L'INIBITOREEEEEEEEEEEEEEEEEEEEEE\n");

	if(shm_info_attach(&stats.info)==-1){
		exit(EXIT_FAILURE);
	}

	sem_execute_semop(shm_sem_get_startid(stats.info), 0, 1, 0);
	sem_execute_semop(shm_sem_get_startid(stats.info), 10, -1, 0);

	while(sem_getval(shm_sem_get_startid(stats.info), 1) != 1){
		if(sem_getval(shm_sem_get_startid(stats.info), 7)==0){
			close_and_exit();
		}
		sleep(1);
	}

	sem_execute_semop(shm_sem_get_startid(stats.info), 6, 1, 0); // questo indica che l'inibitore è attivo, quindi bisogn cmbiare il suo vlore quando lo disaattivimo

	while(sem_getval(shm_sem_get_startid(stats.info), 7)!=0){
		sleep(1);
	}
	close_and_exit();
}

void close_and_exit(){
	shm_info_detach(stats.info);

	//printf("terminazione del processo ACTIVATOR.\n");
	exit(0);

}


 semafore.c
#define _GNU_SOURCE

#include <errno.h>
#include <stdio.h>
#include "semaphore.h"

/* Private functions prototypes */
static struct sembuf create_sembuf(int index, int semop_value, int flags);

int sem_create(key_t sem_key, int nsems) //crea gruppo di semafori
{
	int res;
	if (nsems <= 0) { //bisogna passargli un num di semafori maggiore di 0
		dprintf(2, "semaphore.c - sem_create: nsems must be greater than 0.\n");
		return -1;
	}

	if (( res = semget(sem_key, nsems, 0660 | IPC_CREAT | IPC_EXCL)) < 0) { //crea nsem semafori, sem_key è la chiave univoca che si trova in constants.h, ipc_creat crea l'insieme di semafori associato alla chiave solo se non esiste gia, restituisce l'id se esiste gia, ipc_excl combinato con creat se esiste gia un insieme di sem associato alla chiave semget fallisce restituisce -1 con errore eexist 
		dprintf(2, "semaphore.c - sem_create: Failed to create semaphore array.\n");
	}
	return res; //restituisce id
}

int sem_get_id(key_t key)
{
	int res;
	if ((res = semget(key, 0, 0)) == -1) { //mettendo il secondo e terzo parametro a 0 restituisce l'id dell'insieme di semafori
		dprintf(2, "semaphore.c - sem_get_id: Failed to obtain semaphore array id.\n");
	}
	return res;
}

void sem_setval(id_t sem_id, int sem_index, int value)
{
	if (semctl(sem_id, sem_index, SETVAL, value) < 0) {//usa  semctl per settare il valore iniziale del semaforo di indice em_index
		dprintf(2, "semaphore.c - sem_setval: Failed to set semaphore value\n");
	}
}

int sem_getval(id_t sem_id, int sem_index)
{
	int val=0;
	if ((val = semctl(sem_id, sem_index, GETVAL)) < 0) {//retituisce il valore del semaforo di indice sem_index dell' insieme di semafori di id sem_id
		printf("semaphore.c - sem_getval: Failed to get semaphore value \n");
	}
	return val;
}

void sem_execute_semop(id_t sem_id, int sem_index, int op_val, int flags)
{
	struct sembuf operation; //sembuf è una struct che specifica i parametri per le operazioni che svolge semop
	operation = create_sembuf(sem_index, op_val, flags); //indica l'indice del semaforo su cui lavorare, il valore da assegnargli e i flag tipo ipc_nowait

	while (semop(sem_id, &operation, 1) == -1) {
        if (errno == EINTR || errno == EAGAIN) {// EINTR: L'operazione è stata interrotta da un segnale. Riprovare. EAGAIN: Il semaforo è occupato, ma può essere ritentato. Riprovare.

        } else if (errno == EIDRM || errno == EINVAL) {// EIDRM: Il set di semafori è stato rimosso. Uscire dal ciclo. EINVAL: ID di semaforo non valido o altre condizioni non riparabili.
            printf("semop failed: semaphore set has been removed (EIDRM)\n");
            break;
        } else {// Qualsiasi altro errore. Stampa e esce.
            break;
        }
    }
}

void sem_delete(id_t sem_id)
{
	if (semctl(sem_id, 0, IPC_RMID) < 0) { //cancella la lista di semafori specificando l'id
		dprintf(2, "semaphore.c - sem_delete: Failed to delete semaphore set.\n");
	}
	//printf("list semafori cancellata.\n");
}

static struct sembuf create_sembuf(int index, int semop_value, int flags)//popola la struct sembuf utilizzata da sem_ececute_semop
{
	struct sembuf res;
	res.sem_num = index;
	res.sem_op = semop_value;
	res.sem_flg = flags;

	return res;
}