codice per inviare segnale per fr terminare processi attraverso il loro nome
#include <stdio.h>
#include <stdlib.h>

int main() {
    const char *process_name = "nome_processo";  // Nome del processo a cui inviare il segnale
    int signal = SIGINT; // Il segnale da inviare, ad esempio SIGKILL, SIGTERM

    // Costruzione del comando killall
    char command[256];
    snprintf(command, sizeof(command), "killall -%d %s", signal, process_name);

    // Esecuzione del comando
    int ret = system(command);
    if (ret == -1) {
        perror("Errore nell'esecuzione del comando killall");
    } else {
        printf("Segnale %d inviato a tutti i processi con nome %s\n", signal, process_name);
    }

    return 0;
}




AGGIUSTATO gli inibitori non terminano correttamente


FATTO aggiungere stampe di qunta energia assorbe inibitore e quante scissioni/operazioni fa

sembra che gli accessi alla mem condivisa da parte degli atomi non avvengano in modo cronologico 
facendo si che quantità alte di energia liberate quando si era lontani da explode vengano scritte in memoria
quando si è piu vicini a explode 

EXPLODE da atom non fa terminare l'esecuzione correttamante, gli atomi rimangono in vita
+ master non si chiude quindi si è costretti a fare makekillall-kill per uccidere tutti i processi
dell esecuzione ma rimangono ettive le risorse ipc che devono essere rimosse con make clean se no alla prossima
esecuzione darà errore del semaforo 
Risolto: praticamente explode avviene dentro una sezione ad esecuzione atomica di atom e non rimettevo i semafori
a valori di semaforo libero cosi che tutti gli atomi che aspettavano su quel semaforo rimanevano sempre li ad aspettare

aggiungere le stampe delle operazioni del'inibiotre e 

"AGGIUSTATO" semaphore.c - sem_getval: Failed to get semaphore value
gestire l'uscita dal processo nel caso non si trova la mem condivisa/ semaforo
Grazie all'errore in explode ho capito n po... adesso nel migliore dei casi master e gli atomi terminano correttamente
Nel peggiore dei casi rimangono comunque dei processi attivi ma senza errori, rimangono stranamente in Sleep, notabile
scrivendo ps aux nel terminale e i processi ./atom sono in stato S+ (che sarebbe sleep)
- scavando nei meandri ho capito che praticamente finiscono le risore per fare fork, allora i processi gia creati terminano
correttamente diventando zombie. gli zombie occupano comunque spazio nella tabella dei processi facendo si che gli altri processi che si devono creare
con fork non possono. l'unico modo per liberare gli zombie è di fare una wait() o waitpid() che aspettano la terminazione
dei figli conoscendo il loro pid e quindi puliscono gli zombie, oppure terminiamo il padre, cosi gli zombie vengono adottati
da init che li gestirà al meglio(li toglie di mezzo)
-noi non ci salviamo i pid dei figli quindi mi sembra piu logico terminare il padre quando i figli smettono di terminare da soli
cosi gli zombie se ne vanno e gli altri procesi in sleep perche non possono crearsi, finalmente si tolgono di mezzo da soli nel modo giusto
-penso che sia la sola soluzione perche ho anche provato a inviare segnali ai processi in sleep ma non li ricevono quindi ho 
pensato che non sono nemmeno stati inizializzati anche perche poi nelle stampe del terminale mi usciva scritto un errore sh: 1: Cannot fork
quindi sembra che i processi volevano an cora forkarsi? ma io che ne so. poi bho è solo un mio pensiero.

magari aggiungere anche dei limiti sulla quantità di atomi creabili come atomi iniziali  perche se 
inizializzo l'esecuzione con un numero troppo alto di atomi , che supera gia i limiti di sistema, es quelli
di cgroup o di user_limit, allora le fork potrebbero fallire prima dell'inizio dell'esecuzione.
vedere come gestire


aggiungere un semaforo che avvisa che ci sono delle fork in corso cosi che master deve aspettare che tutte le 
fork teminino poi puo chiudersi e nel frattempo pero non possono essere vviate nuove fork
quindi di sicuro master o chi di sovere setta il valore di semaforo di esecuzione a 0 e poi si aspettano le foork

errore del makefile quando uso make killall kill  (non è proprio un errore ma meglio aggiustare macari)


processo inibitore 

DA FARE ME SA assorbe parte della quantit`a di energia prodotta dalla scissione dell’atomo diminuendo la quantit`a di energia
che viene liberata (QUESTO AGISCE DIRETTAMENTE NELL'ATOMO, ATOMO CONTROLLA MEM CONDIVIDSA CHE L'INIBITOE SIA ATTIVATO E MODIFICA LA FUNZIONE DI ENERGIA LIBERATA
IMPLICA UN SEMAFORO O UNA VARIABILE IN MEMORIA CONDIVISA)


FATTO limita il numero di scissioni agendo sull’operazione di scissione rendendola probabilistica (ad esempio decidendo
se la scissione debba avvenire o meno oppure trasformando in scoria uno degli atomi prodotti dopo la scissione)(STESSA COSA, L'ATOMO CONTROLLA CHE L'INIBITORE SIA ATTIVO CON UN SEMAFORO E 
USA UNA FUNZIONE RANDOMICA DI 3 NUMERI PER SCISSIONE, NON SCISSIONE O SCISSIONE E UNO DEI DUE ATOMI PRODOTTI DIVENTA SCORIA)
4
Il meccanismo di assorbimento e quello di limitazione delle scissioni sono scelti dal programmatore e devono
essere basati su qualche criterio adattivo.


FATTO La presenza o meno del processo inibitore deve poter essere scelta a run-time, all’inizio della simulazione.

 Nel caso in cui il processo inibitore sia attivo, ci si aspetta che la terminazione per “explode” e “meltdown” non avvenga.
Inoltre, l’utente deve poter fermare (e far ripartire) il processo inibitore pi`u volte da terminale attraverso un
meccanismo a scelta del programmatore

PER FARLO BLOCCARE O RIPARTIRE SI USANO SEGNALI DA LINE ADI COMANDO

    